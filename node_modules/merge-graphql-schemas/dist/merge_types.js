'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _graphql = require('graphql');

var _buildASTSchema = require('graphql/utilities/buildASTSchema');

var _astPrinter = require('./utilities/astPrinter');

var _astPrinter2 = _interopRequireDefault(_astPrinter);

var _astHelpers = require('./utilities/astHelpers');

var _makeSchema = require('./utilities/makeSchema');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const _isMergeableTypeDefinition = def => (0, _astHelpers.isObjectTypeDefinition)(def) && _makeSchema.mergeableTypes.includes(def.name.value); // Test


const _isNonMergeableTypeDefinition = def => !_isMergeableTypeDefinition(def);

const _makeCommentNode = value => ({ kind: 'Comment', value: value });

const _addCommentsToAST = function _addCommentsToAST(nodes) {
  let flatten = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  const astWithComments = nodes.map(node => {
    const description = (0, _buildASTSchema.getDescription)(node);
    if (description) {
      return [_makeCommentNode(description), node];
    }

    return [node];
  });

  if (flatten) {
    return astWithComments.reduce((a, b) => a.concat(b), []);
  }

  return astWithComments;
};

const _makeRestDefinitions = defs => defs.filter(def => _isNonMergeableTypeDefinition(def) && !(0, _astHelpers.isObjectSchemaDefinition)(def)).map(def => {
  if ((0, _astHelpers.isObjectTypeDefinition)(def)) {
    return (0, _extends3.default)({}, def, {
      fields: _addCommentsToAST(def.fields)
    });
  }

  return def;
});

const _makeMergedDefinitions = defs => {
  // TODO: This function can be cleaner!
  const groupedMergableDefinitions = defs.filter(_isMergeableTypeDefinition).reduce((mergableDefs, def) => {
    const name = def.name.value;

    if (!mergableDefs[name]) {
      return (0, _extends3.default)({}, mergableDefs, {
        [name]: (0, _extends3.default)({}, def, {
          fields: _addCommentsToAST(def.fields)
        })
      });
    }

    return (0, _extends3.default)({}, mergableDefs, {
      [name]: (0, _extends3.default)({}, mergableDefs[name], {
        fields: [].concat((0, _toConsumableArray3.default)(mergableDefs[name].fields), (0, _toConsumableArray3.default)(_addCommentsToAST(def.fields)))
      })
    });
  }, {
    Query: null,
    Mutation: null,
    Subscription: null
  });

  return (0, _values2.default)(groupedMergableDefinitions).reduce((array, def) => def ? [].concat((0, _toConsumableArray3.default)(array), [def]) : array, []);
};

const _makeDocumentWithDefinitions = definitions => ({
  kind: 'Document',
  definitions: definitions instanceof Array ? definitions : [definitions]
});

const printDefinitions = defs => (0, _astPrinter2.default)(_makeDocumentWithDefinitions(defs));

const mergeTypes = types => {
  const allDefs = types.map(_graphql.parse).map(ast => ast.definitions).reduce((defs, newDef) => [].concat((0, _toConsumableArray3.default)(defs), (0, _toConsumableArray3.default)(newDef)), []);

  const mergedDefs = _makeMergedDefinitions(allDefs);
  const rest = _addCommentsToAST(_makeRestDefinitions(allDefs), false).map(printDefinitions);
  const schemaDefs = allDefs.filter(_astHelpers.isObjectSchemaDefinition);
  const schema = printDefinitions([(0, _makeSchema.makeSchema)(mergedDefs, schemaDefs)].concat((0, _toConsumableArray3.default)(mergedDefs)));

  return [schema].concat((0, _toConsumableArray3.default)(rest)).join('\n');
};

exports.default = mergeTypes;